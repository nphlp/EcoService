import PrismaInstance from "@lib/prisma";
import { Prisma } from "@prisma/client";
import {
    QuantityCountProps,
    QuantityCountResponse,
    QuantityCreateManyProps,
    QuantityCreateManyResponse,
    QuantityCreateProps,
    QuantityCreateResponse,
    QuantityDeleteManyProps,
    QuantityDeleteManyResponse,
    QuantityDeleteProps,
    QuantityDeleteResponse,
    QuantityFindFirstProps,
    QuantityFindFirstResponse,
    QuantityFindManyProps,
    QuantityFindManyResponse,
    QuantityFindUniqueProps,
    QuantityFindUniqueResponse,
    QuantityUpdateManyProps,
    QuantityUpdateManyResponse,
    QuantityUpdateProps,
    QuantityUpdateResponse,
    QuantityUpsertProps,
    QuantityUpsertResponse,
} from "@services/types";

/**
 * # Quantity Class Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/class/{{model}}Class.hbs` as base template
 * - to generate class function files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

/**
 * ## Quantity Class
 */
export default class QuantityService {
    /**
     * ## Quantity Create (Class)
     */
    static async create<T extends Prisma.QuantityCreateArgs>(
        props: QuantityCreateProps<T>,
    ): Promise<QuantityCreateResponse<T>> {
        try {
            return await PrismaInstance.quantity.create(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Upsert (Class)
     */
    static async upsert<T extends Prisma.QuantityUpsertArgs>(
        props: QuantityUpsertProps<T>,
    ): Promise<QuantityUpsertResponse<T>> {
        try {
            return await PrismaInstance.quantity.upsert(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Update (Class)
     */
    static async update<T extends Prisma.QuantityUpdateArgs>(
        props: QuantityUpdateProps<T>,
    ): Promise<QuantityUpdateResponse<T>> {
        try {
            return await PrismaInstance.quantity.update(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Delete (Class)
     */
    static async delete<T extends Prisma.QuantityDeleteArgs>(
        props: QuantityDeleteProps<T>,
    ): Promise<QuantityDeleteResponse<T>> {
        try {
            return await PrismaInstance.quantity.delete(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Create Many (Class)
     */
    static async createMany<T extends Prisma.QuantityCreateManyArgs>(
        props: QuantityCreateManyProps<T>,
    ): Promise<QuantityCreateManyResponse> {
        try {
            return await PrismaInstance.quantity.createMany(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Update Many (Class)
     */
    static async updateMany<T extends Prisma.QuantityUpdateManyArgs>(
        props: QuantityUpdateManyProps<T>,
    ): Promise<QuantityUpdateManyResponse> {
        try {
            return await PrismaInstance.quantity.updateMany(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Delete Many (Class)
     */
    static async deleteMany<T extends Prisma.QuantityDeleteManyArgs>(
        props: QuantityDeleteManyProps<T>,
    ): Promise<QuantityDeleteManyResponse> {
        try {
            return await PrismaInstance.quantity.deleteMany(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Find First (Class)
     */
    static async findFirst<T extends Prisma.QuantityFindFirstArgs>(
        props: QuantityFindFirstProps<T>,
    ): Promise<QuantityFindFirstResponse<T>> {
        try {
            return await PrismaInstance.quantity.findFirst(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Find Unique (Class)
     */
    static async findUnique<T extends Prisma.QuantityFindUniqueArgs>(
        props: QuantityFindUniqueProps<T>,
    ): Promise<QuantityFindUniqueResponse<T>> {
        try {
            return await PrismaInstance.quantity.findUnique(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Find Many (Class)
     */
    static async findMany<T extends Prisma.QuantityFindManyArgs>(
        props: QuantityFindManyProps<T>,
    ): Promise<QuantityFindManyResponse<T>> {
        try {
            return await PrismaInstance.quantity.findMany(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Quantity Count (Class)
     */
    static async count<T extends Prisma.QuantityCountArgs>(
        props: QuantityCountProps<T>,
    ): Promise<QuantityCountResponse<T>> {
        try {
            return await PrismaInstance.quantity.count(props);
        } catch (error) {
            throw QuantityService.error(error);
        }
    }

    /**
     * ## Error handling (Class)
     */
    private static async error(error: unknown): Promise<{ error: string }> {
        if (process.env.NODE_ENV === "development") {
            const message = (error as Error).message;
            console.error(message);
            throw new Error(message);
        }

        // TODO: add logging
        // await Logging(error);

        // Return safe error message to client
        throw new Error("Something went wrong...");
    }
}
