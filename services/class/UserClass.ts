import PrismaInstance from "@lib/prisma";
import { Prisma } from "@prisma/client";
import { PrismaClientKnownRequestError } from "@prisma/client/runtime/library";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";
import { ResponseFormat } from "@utils/FetchConfig";

/**
 * # User Class Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/class/{{model}}Class.hbs` as base template
 * - to generate class function files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type UserCreateProps<T extends Prisma.UserCreateArgs> = Prisma.SelectSubset<T, Prisma.UserCreateArgs>;
type UserCreateResponse<T extends Prisma.UserCreateArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type UserUpsertProps<T extends Prisma.UserUpsertArgs> = Prisma.SelectSubset<T, Prisma.UserUpsertArgs>;
type UserUpsertResponse<T extends Prisma.UserUpsertArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type UserUpdateProps<T extends Prisma.UserUpdateArgs> = Prisma.SelectSubset<T, Prisma.UserUpdateArgs>;
type UserUpdateResponse<T extends Prisma.UserUpdateArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type UserDeleteProps<T extends Prisma.UserDeleteArgs> = Prisma.SelectSubset<T, Prisma.UserDeleteArgs>;
type UserDeleteResponse<T extends Prisma.UserDeleteArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type UserCreateManyProps<T extends Prisma.UserCreateManyArgs> = Prisma.SelectSubset<T, Prisma.UserCreateManyArgs>;
type UserCreateManyResponse = Prisma.BatchPayload;

// Update Many
type UserUpdateManyProps<T extends Prisma.UserUpdateManyArgs> = Prisma.SelectSubset<T, Prisma.UserUpdateManyArgs>;
type UserUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type UserDeleteManyProps<T extends Prisma.UserDeleteManyArgs> = Prisma.SelectSubset<T, Prisma.UserDeleteManyArgs>;
type UserDeleteManyResponse = Prisma.BatchPayload;

// Find First
type UserFindFirstProps<T extends Prisma.UserFindFirstArgs> = Prisma.SelectSubset<T, Prisma.UserFindFirstArgs>;
type UserFindFirstResponse<T extends Prisma.UserFindFirstArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type UserFindUniqueProps<T extends Prisma.UserFindUniqueArgs> = Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>;
type UserFindUniqueResponse<T extends Prisma.UserFindUniqueArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type UserFindManyProps<T extends Prisma.UserFindManyArgs> = Prisma.SelectSubset<T, Prisma.UserFindManyArgs>;
type UserFindManyResponse<T extends Prisma.UserFindManyArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type UserCountProps<T extends Prisma.UserCountArgs> = Prisma.SelectSubset<T, Prisma.UserCountArgs>;
type UserCountResponse<T extends Prisma.UserCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.UserCountAggregateOutputType>
        : number;

/**
 * ## User Class
 */
export default class UserService {
    /**
     * ## User Create (Class)
     */
    static async create<T extends Prisma.UserCreateArgs>(
        props: UserCreateProps<T>,
    ): Promise<ResponseFormat<UserCreateResponse<T>>> {
        try {
            const user = await PrismaInstance.user.create(props);
            return { data: user };
        } catch (error) {
            return UserService.error("create", error);
        }
    }

    /**
     * ## User Upsert (Class)
     */
    static async upsert<T extends Prisma.UserUpsertArgs>(
        props: UserUpsertProps<T>,
    ): Promise<ResponseFormat<UserUpsertResponse<T>>> {
        try {
            const user = await PrismaInstance.user.upsert(props);
            return { data: user };
        } catch (error) {
            return UserService.error("upsert", error);
        }
    }

    /**
     * ## User Update (Class)
     */
    static async update<T extends Prisma.UserUpdateArgs>(
        props: UserUpdateProps<T>,
    ): Promise<ResponseFormat<UserUpdateResponse<T>>> {
        try {
            const user = await PrismaInstance.user.update(props);
            return { data: user };
        } catch (error) {
            return UserService.error("update", error);
        }
    }

    /**
     * ## User Delete (Class)
     */
    static async delete<T extends Prisma.UserDeleteArgs>(
        props: UserDeleteProps<T>,
    ): Promise<ResponseFormat<UserDeleteResponse<T>>> {
        try {
            const user = await PrismaInstance.user.delete(props);
            return { data: user };
        } catch (error) {
            return UserService.error("delete", error);
        }
    }

    /**
     * ## User Create Many (Class)
     */
    static async createMany<T extends Prisma.UserCreateManyArgs>(
        props: UserCreateManyProps<T>,
    ): Promise<ResponseFormat<UserCreateManyResponse>> {
        try {
            const result = await PrismaInstance.user.createMany(props);
            return { data: result };
        } catch (error) {
            return UserService.error("createMany", error);
        }
    }

    /**
     * ## User Update Many (Class)
     */
    static async updateMany<T extends Prisma.UserUpdateManyArgs>(
        props: UserUpdateManyProps<T>,
    ): Promise<ResponseFormat<UserUpdateManyResponse>> {
        try {
            const result = await PrismaInstance.user.updateMany(props);
            return { data: result };
        } catch (error) {
            return UserService.error("updateMany", error);
        }
    }

    /**
     * ## User Delete Many (Class)
     */
    static async deleteMany<T extends Prisma.UserDeleteManyArgs>(
        props: UserDeleteManyProps<T>,
    ): Promise<ResponseFormat<UserDeleteManyResponse>> {
        try {
            const result = await PrismaInstance.user.deleteMany(props);
            return { data: result };
        } catch (error) {
            return UserService.error("deleteMany", error);
        }
    }

    /**
     * ## User Find First (Class)
     */
    static async findFirst<T extends Prisma.UserFindFirstArgs>(
        props: UserFindFirstProps<T>,
    ): Promise<ResponseFormat<UserFindFirstResponse<T>>> {
        try {
            const user = await PrismaInstance.user.findFirst(props);
            return { data: user };
        } catch (error) {
            return UserService.error("findFirst", error);
        }
    }

    /**
     * ## User Find Unique (Class)
     */
    static async findUnique<T extends Prisma.UserFindUniqueArgs>(
        props: UserFindUniqueProps<T>,
    ): Promise<ResponseFormat<UserFindUniqueResponse<T>>> {
        try {
            const user = await PrismaInstance.user.findUnique(props);
            return { data: user };
        } catch (error) {
            return UserService.error("findUnique", error);
        }
    }

    /**
     * ## User Find Many (Class)
     */
    static async findMany<T extends Prisma.UserFindManyArgs>(
        props: UserFindManyProps<T>,
    ): Promise<ResponseFormat<UserFindManyResponse<T>>> {
        try {
            const userList = await PrismaInstance.user.findMany(props);
            return { data: userList };
        } catch (error) {
            return UserService.error("findMany", error);
        }
    }

    /**
     * ## User Count (Class)
     */
    static async count<T extends Prisma.UserCountArgs>(
        props: UserCountProps<T>,
    ): Promise<ResponseFormat<UserCountResponse<T>>> {
        try {
            const userAmount = await PrismaInstance.user.count(props);
            return { data: userAmount };
        } catch (error) {
            return UserService.error("count", error);
        }
    }

    /**
     * ## Error handling (Class)
     */
    private static async error(methodName: string, error: unknown): Promise<{ error: string }> {
        if (process.env.NODE_ENV === "development") {
            const serviceName = this.constructor.name;
            const message = (error as Error).message;
            if (error instanceof PrismaClientKnownRequestError) {
                const prismaMessage = serviceName + " -> " + methodName + " -> Prisma error -> " + error.message;
                console.error(prismaMessage);
                throw new Error(prismaMessage);
            } else {
                const errorMessage = serviceName + " -> " + methodName + " -> " + message;
                console.error(errorMessage);
                throw new Error(errorMessage);
            }
        }
        // TODO: add logging
        return { error: "Something went wrong..." };
    }
}
