import PrismaInstance from "@lib/prisma";
import { Prisma } from "@prisma/client";
import { PrismaClientKnownRequestError } from "@prisma/client/runtime/library";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";
import { ResponseFormat } from "@utils/FetchConfig";

/**
 * # Fruit Class Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/class/{{model}}Class.hbs` as base template
 * - to generate class function files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type FruitCreateProps<T extends Prisma.FruitCreateArgs> = Prisma.SelectSubset<T, Prisma.FruitCreateArgs>;
type FruitCreateResponse<T extends Prisma.FruitCreateArgs> = GetResult<
    Prisma.$FruitPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type FruitUpsertProps<T extends Prisma.FruitUpsertArgs> = Prisma.SelectSubset<T, Prisma.FruitUpsertArgs>;
type FruitUpsertResponse<T extends Prisma.FruitUpsertArgs> = GetResult<
    Prisma.$FruitPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type FruitUpdateProps<T extends Prisma.FruitUpdateArgs> = Prisma.SelectSubset<T, Prisma.FruitUpdateArgs>;
type FruitUpdateResponse<T extends Prisma.FruitUpdateArgs> = GetResult<
    Prisma.$FruitPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type FruitDeleteProps<T extends Prisma.FruitDeleteArgs> = Prisma.SelectSubset<T, Prisma.FruitDeleteArgs>;
type FruitDeleteResponse<T extends Prisma.FruitDeleteArgs> = GetResult<
    Prisma.$FruitPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type FruitCreateManyProps<T extends Prisma.FruitCreateManyArgs> = Prisma.SelectSubset<T, Prisma.FruitCreateManyArgs>;
type FruitCreateManyResponse = Prisma.BatchPayload;

// Update Many
type FruitUpdateManyProps<T extends Prisma.FruitUpdateManyArgs> = Prisma.SelectSubset<T, Prisma.FruitUpdateManyArgs>;
type FruitUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type FruitDeleteManyProps<T extends Prisma.FruitDeleteManyArgs> = Prisma.SelectSubset<T, Prisma.FruitDeleteManyArgs>;
type FruitDeleteManyResponse = Prisma.BatchPayload;

// Find First
type FruitFindFirstProps<T extends Prisma.FruitFindFirstArgs> = Prisma.SelectSubset<T, Prisma.FruitFindFirstArgs>;
type FruitFindFirstResponse<T extends Prisma.FruitFindFirstArgs> = GetResult<
    Prisma.$FruitPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type FruitFindUniqueProps<T extends Prisma.FruitFindUniqueArgs> = Prisma.SelectSubset<T, Prisma.FruitFindUniqueArgs>;
type FruitFindUniqueResponse<T extends Prisma.FruitFindUniqueArgs> = GetResult<
    Prisma.$FruitPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type FruitFindManyProps<T extends Prisma.FruitFindManyArgs> = Prisma.SelectSubset<T, Prisma.FruitFindManyArgs>;
type FruitFindManyResponse<T extends Prisma.FruitFindManyArgs> = GetResult<
    Prisma.$FruitPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type FruitCountProps<T extends Prisma.FruitCountArgs> = Prisma.SelectSubset<T, Prisma.FruitCountArgs>;
type FruitCountResponse<T extends Prisma.FruitCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.FruitCountAggregateOutputType>
        : number;

/**
 * ## Fruit Class
 */
export default class FruitService {
    /**
     * ## Fruit Create (Class)
     */
    static async create<T extends Prisma.FruitCreateArgs>(
        props: FruitCreateProps<T>,
    ): Promise<ResponseFormat<FruitCreateResponse<T>>> {
        try {
            const fruit = await PrismaInstance.fruit.create(props);
            return { data: fruit };
        } catch (error) {
            return FruitService.error("create", error);
        }
    }

    /**
     * ## Fruit Upsert (Class)
     */
    static async upsert<T extends Prisma.FruitUpsertArgs>(
        props: FruitUpsertProps<T>,
    ): Promise<ResponseFormat<FruitUpsertResponse<T>>> {
        try {
            const fruit = await PrismaInstance.fruit.upsert(props);
            return { data: fruit };
        } catch (error) {
            return FruitService.error("upsert", error);
        }
    }

    /**
     * ## Fruit Update (Class)
     */
    static async update<T extends Prisma.FruitUpdateArgs>(
        props: FruitUpdateProps<T>,
    ): Promise<ResponseFormat<FruitUpdateResponse<T>>> {
        try {
            const fruit = await PrismaInstance.fruit.update(props);
            return { data: fruit };
        } catch (error) {
            return FruitService.error("update", error);
        }
    }

    /**
     * ## Fruit Delete (Class)
     */
    static async delete<T extends Prisma.FruitDeleteArgs>(
        props: FruitDeleteProps<T>,
    ): Promise<ResponseFormat<FruitDeleteResponse<T>>> {
        try {
            const fruit = await PrismaInstance.fruit.delete(props);
            return { data: fruit };
        } catch (error) {
            return FruitService.error("delete", error);
        }
    }

    /**
     * ## Fruit Create Many (Class)
     */
    static async createMany<T extends Prisma.FruitCreateManyArgs>(
        props: FruitCreateManyProps<T>,
    ): Promise<ResponseFormat<FruitCreateManyResponse>> {
        try {
            const result = await PrismaInstance.fruit.createMany(props);
            return { data: result };
        } catch (error) {
            return FruitService.error("createMany", error);
        }
    }

    /**
     * ## Fruit Update Many (Class)
     */
    static async updateMany<T extends Prisma.FruitUpdateManyArgs>(
        props: FruitUpdateManyProps<T>,
    ): Promise<ResponseFormat<FruitUpdateManyResponse>> {
        try {
            const result = await PrismaInstance.fruit.updateMany(props);
            return { data: result };
        } catch (error) {
            return FruitService.error("updateMany", error);
        }
    }

    /**
     * ## Fruit Delete Many (Class)
     */
    static async deleteMany<T extends Prisma.FruitDeleteManyArgs>(
        props: FruitDeleteManyProps<T>,
    ): Promise<ResponseFormat<FruitDeleteManyResponse>> {
        try {
            const result = await PrismaInstance.fruit.deleteMany(props);
            return { data: result };
        } catch (error) {
            return FruitService.error("deleteMany", error);
        }
    }

    /**
     * ## Fruit Find First (Class)
     */
    static async findFirst<T extends Prisma.FruitFindFirstArgs>(
        props: FruitFindFirstProps<T>,
    ): Promise<ResponseFormat<FruitFindFirstResponse<T>>> {
        try {
            const fruit = await PrismaInstance.fruit.findFirst(props);
            return { data: fruit };
        } catch (error) {
            return FruitService.error("findFirst", error);
        }
    }

    /**
     * ## Fruit Find Unique (Class)
     */
    static async findUnique<T extends Prisma.FruitFindUniqueArgs>(
        props: FruitFindUniqueProps<T>,
    ): Promise<ResponseFormat<FruitFindUniqueResponse<T>>> {
        try {
            const fruit = await PrismaInstance.fruit.findUnique(props);
            return { data: fruit };
        } catch (error) {
            return FruitService.error("findUnique", error);
        }
    }

    /**
     * ## Fruit Find Many (Class)
     */
    static async findMany<T extends Prisma.FruitFindManyArgs>(
        props: FruitFindManyProps<T>,
    ): Promise<ResponseFormat<FruitFindManyResponse<T>>> {
        try {
            const fruitList = await PrismaInstance.fruit.findMany(props);
            return { data: fruitList };
        } catch (error) {
            return FruitService.error("findMany", error);
        }
    }

    /**
     * ## Fruit Count (Class)
     */
    static async count<T extends Prisma.FruitCountArgs>(
        props: FruitCountProps<T>,
    ): Promise<ResponseFormat<FruitCountResponse<T>>> {
        try {
            const fruitAmount = await PrismaInstance.fruit.count(props);
            return { data: fruitAmount };
        } catch (error) {
            return FruitService.error("count", error);
        }
    }

    /**
     * ## Error handling (Class)
     */
    private static async error(methodName: string, error: unknown): Promise<{ error: string }> {
        if (process.env.NODE_ENV === "development") {
            const serviceName = this.constructor.name;
            const message = (error as Error).message;
            if (error instanceof PrismaClientKnownRequestError) {
                const prismaMessage = serviceName + " -> " + methodName + " -> Prisma error -> " + error.message;
                console.error(prismaMessage);
                throw new Error(prismaMessage);
            } else {
                const errorMessage = serviceName + " -> " + methodName + " -> " + message;
                console.error(errorMessage);
                throw new Error(errorMessage);
            }
        }
        // TODO: add logging
        return { error: "Something went wrong..." };
    }
}
