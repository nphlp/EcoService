import PrismaInstance from "@lib/prisma";
import { Prisma } from "@prisma/client";
import { PrismaClientKnownRequestError } from "@prisma/client/runtime/library";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";
import { ResponseFormat } from "@utils/FetchConfig";

/**
 * # Content Class Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/class/{{model}}Class.hbs` as base template
 * - to generate class function files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type ContentCreateProps<T extends Prisma.ContentCreateArgs> = Prisma.SelectSubset<T, Prisma.ContentCreateArgs>;
type ContentCreateResponse<T extends Prisma.ContentCreateArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type ContentUpsertProps<T extends Prisma.ContentUpsertArgs> = Prisma.SelectSubset<T, Prisma.ContentUpsertArgs>;
type ContentUpsertResponse<T extends Prisma.ContentUpsertArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type ContentUpdateProps<T extends Prisma.ContentUpdateArgs> = Prisma.SelectSubset<T, Prisma.ContentUpdateArgs>;
type ContentUpdateResponse<T extends Prisma.ContentUpdateArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type ContentDeleteProps<T extends Prisma.ContentDeleteArgs> = Prisma.SelectSubset<T, Prisma.ContentDeleteArgs>;
type ContentDeleteResponse<T extends Prisma.ContentDeleteArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type ContentCreateManyProps<T extends Prisma.ContentCreateManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ContentCreateManyArgs
>;
type ContentCreateManyResponse = Prisma.BatchPayload;

// Update Many
type ContentUpdateManyProps<T extends Prisma.ContentUpdateManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ContentUpdateManyArgs
>;
type ContentUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type ContentDeleteManyProps<T extends Prisma.ContentDeleteManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ContentDeleteManyArgs
>;
type ContentDeleteManyResponse = Prisma.BatchPayload;

// Find First
type ContentFindFirstProps<T extends Prisma.ContentFindFirstArgs> = Prisma.SelectSubset<T, Prisma.ContentFindFirstArgs>;
type ContentFindFirstResponse<T extends Prisma.ContentFindFirstArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type ContentFindUniqueProps<T extends Prisma.ContentFindUniqueArgs> = Prisma.SelectSubset<
    T,
    Prisma.ContentFindUniqueArgs
>;
type ContentFindUniqueResponse<T extends Prisma.ContentFindUniqueArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type ContentFindManyProps<T extends Prisma.ContentFindManyArgs> = Prisma.SelectSubset<T, Prisma.ContentFindManyArgs>;
type ContentFindManyResponse<T extends Prisma.ContentFindManyArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type ContentCountProps<T extends Prisma.ContentCountArgs> = Prisma.SelectSubset<T, Prisma.ContentCountArgs>;
type ContentCountResponse<T extends Prisma.ContentCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.ContentCountAggregateOutputType>
        : number;

/**
 * ## Content Class
 */
export default class ContentService {
    /**
     * ## Content Create (Class)
     */
    static async create<T extends Prisma.ContentCreateArgs>(
        props: ContentCreateProps<T>,
    ): Promise<ResponseFormat<ContentCreateResponse<T>>> {
        try {
            const content = await PrismaInstance.content.create(props);
            return { data: content };
        } catch (error) {
            return ContentService.error("create", error);
        }
    }

    /**
     * ## Content Upsert (Class)
     */
    static async upsert<T extends Prisma.ContentUpsertArgs>(
        props: ContentUpsertProps<T>,
    ): Promise<ResponseFormat<ContentUpsertResponse<T>>> {
        try {
            const content = await PrismaInstance.content.upsert(props);
            return { data: content };
        } catch (error) {
            return ContentService.error("upsert", error);
        }
    }

    /**
     * ## Content Update (Class)
     */
    static async update<T extends Prisma.ContentUpdateArgs>(
        props: ContentUpdateProps<T>,
    ): Promise<ResponseFormat<ContentUpdateResponse<T>>> {
        try {
            const content = await PrismaInstance.content.update(props);
            return { data: content };
        } catch (error) {
            return ContentService.error("update", error);
        }
    }

    /**
     * ## Content Delete (Class)
     */
    static async delete<T extends Prisma.ContentDeleteArgs>(
        props: ContentDeleteProps<T>,
    ): Promise<ResponseFormat<ContentDeleteResponse<T>>> {
        try {
            const content = await PrismaInstance.content.delete(props);
            return { data: content };
        } catch (error) {
            return ContentService.error("delete", error);
        }
    }

    /**
     * ## Content Create Many (Class)
     */
    static async createMany<T extends Prisma.ContentCreateManyArgs>(
        props: ContentCreateManyProps<T>,
    ): Promise<ResponseFormat<ContentCreateManyResponse>> {
        try {
            const result = await PrismaInstance.content.createMany(props);
            return { data: result };
        } catch (error) {
            return ContentService.error("createMany", error);
        }
    }

    /**
     * ## Content Update Many (Class)
     */
    static async updateMany<T extends Prisma.ContentUpdateManyArgs>(
        props: ContentUpdateManyProps<T>,
    ): Promise<ResponseFormat<ContentUpdateManyResponse>> {
        try {
            const result = await PrismaInstance.content.updateMany(props);
            return { data: result };
        } catch (error) {
            return ContentService.error("updateMany", error);
        }
    }

    /**
     * ## Content Delete Many (Class)
     */
    static async deleteMany<T extends Prisma.ContentDeleteManyArgs>(
        props: ContentDeleteManyProps<T>,
    ): Promise<ResponseFormat<ContentDeleteManyResponse>> {
        try {
            const result = await PrismaInstance.content.deleteMany(props);
            return { data: result };
        } catch (error) {
            return ContentService.error("deleteMany", error);
        }
    }

    /**
     * ## Content Find First (Class)
     */
    static async findFirst<T extends Prisma.ContentFindFirstArgs>(
        props: ContentFindFirstProps<T>,
    ): Promise<ResponseFormat<ContentFindFirstResponse<T>>> {
        try {
            const content = await PrismaInstance.content.findFirst(props);
            return { data: content };
        } catch (error) {
            return ContentService.error("findFirst", error);
        }
    }

    /**
     * ## Content Find Unique (Class)
     */
    static async findUnique<T extends Prisma.ContentFindUniqueArgs>(
        props: ContentFindUniqueProps<T>,
    ): Promise<ResponseFormat<ContentFindUniqueResponse<T>>> {
        try {
            const content = await PrismaInstance.content.findUnique(props);
            return { data: content };
        } catch (error) {
            return ContentService.error("findUnique", error);
        }
    }

    /**
     * ## Content Find Many (Class)
     */
    static async findMany<T extends Prisma.ContentFindManyArgs>(
        props: ContentFindManyProps<T>,
    ): Promise<ResponseFormat<ContentFindManyResponse<T>>> {
        try {
            const contentList = await PrismaInstance.content.findMany(props);
            return { data: contentList };
        } catch (error) {
            return ContentService.error("findMany", error);
        }
    }

    /**
     * ## Content Count (Class)
     */
    static async count<T extends Prisma.ContentCountArgs>(
        props: ContentCountProps<T>,
    ): Promise<ResponseFormat<ContentCountResponse<T>>> {
        try {
            const contentAmount = await PrismaInstance.content.count(props);
            return { data: contentAmount };
        } catch (error) {
            return ContentService.error("count", error);
        }
    }

    /**
     * ## Error handling (Class)
     */
    private static async error(methodName: string, error: unknown): Promise<{ error: string }> {
        if (process.env.NODE_ENV === "development") {
            const serviceName = this.constructor.name;
            const message = (error as Error).message;
            if (error instanceof PrismaClientKnownRequestError) {
                const prismaMessage = serviceName + " -> " + methodName + " -> Prisma error -> " + error.message;
                console.error(prismaMessage);
                throw new Error(prismaMessage);
            } else {
                const errorMessage = serviceName + " -> " + methodName + " -> " + message;
                console.error(errorMessage);
                throw new Error(errorMessage);
            }
        }
        // TODO: add logging
        return { error: "Something went wrong..." };
    }
}
