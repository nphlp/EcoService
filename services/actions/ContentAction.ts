"use server";

import PrismaInstance from "@lib/prisma";
import { requiresSafeMessage } from "@permissions/requiresSafeMessage";
import { Prisma } from "@prisma/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";

/**
 * # Content Action Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/actions/{{model}}Action.hbs` as base template
 * - to generate server actions files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type ContentCreateProps<T extends Prisma.ContentCreateArgs> = Prisma.SelectSubset<T, Prisma.ContentCreateArgs>;
type ContentCreateResponse<T extends Prisma.ContentCreateArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type ContentUpsertProps<T extends Prisma.ContentUpsertArgs> = Prisma.SelectSubset<T, Prisma.ContentUpsertArgs>;
type ContentUpsertResponse<T extends Prisma.ContentUpsertArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type ContentUpdateProps<T extends Prisma.ContentUpdateArgs> = Prisma.SelectSubset<T, Prisma.ContentUpdateArgs>;
type ContentUpdateResponse<T extends Prisma.ContentUpdateArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type ContentDeleteProps<T extends Prisma.ContentDeleteArgs> = Prisma.SelectSubset<T, Prisma.ContentDeleteArgs>;
type ContentDeleteResponse<T extends Prisma.ContentDeleteArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type ContentCreateManyProps<T extends Prisma.ContentCreateManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ContentCreateManyArgs
>;
type ContentCreateManyResponse = Prisma.BatchPayload;

// Update Many
type ContentUpdateManyProps<T extends Prisma.ContentUpdateManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ContentUpdateManyArgs
>;
type ContentUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type ContentDeleteManyProps<T extends Prisma.ContentDeleteManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ContentDeleteManyArgs
>;
type ContentDeleteManyResponse = Prisma.BatchPayload;

// Find First
type ContentFindFirstProps<T extends Prisma.ContentFindFirstArgs> = Prisma.SelectSubset<T, Prisma.ContentFindFirstArgs>;
type ContentFindFirstResponse<T extends Prisma.ContentFindFirstArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type ContentFindUniqueProps<T extends Prisma.ContentFindUniqueArgs> = Prisma.SelectSubset<
    T,
    Prisma.ContentFindUniqueArgs
>;
type ContentFindUniqueResponse<T extends Prisma.ContentFindUniqueArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type ContentFindManyProps<T extends Prisma.ContentFindManyArgs> = Prisma.SelectSubset<T, Prisma.ContentFindManyArgs>;
type ContentFindManyResponse<T extends Prisma.ContentFindManyArgs> = GetResult<
    Prisma.$ContentPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type ContentCountProps<T extends Prisma.ContentCountArgs> = Prisma.SelectSubset<T, Prisma.ContentCountArgs>;
type ContentCountResponse<T extends Prisma.ContentCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.ContentCountAggregateOutputType>
        : number;

// ========== Services ========== //

/**
 * ## Content Create (Server Action)
 */
export const ContentCreateAction = async <T extends Prisma.ContentCreateArgs>(
    props: ContentCreateProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentCreateResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentCreateAction", "Content", "create");
        const response = await PrismaInstance.content.create(props);
        return response;
    } catch (error) {
        throw new Error("ContentCreateAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Upsert (Server Action)
 */
export const ContentUpsertAction = async <T extends Prisma.ContentUpsertArgs>(
    props: ContentUpsertProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentUpsertResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentUpsertAction", "Content", "upsert");
        const response = await PrismaInstance.content.upsert(props);
        return response;
    } catch (error) {
        throw new Error("ContentUpsertAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Update (Server Action)
 */
export const ContentUpdateAction = async <T extends Prisma.ContentUpdateArgs>(
    props: ContentUpdateProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentUpdateResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentUpdateAction", "Content", "update");
        const response = await PrismaInstance.content.update(props);
        return response;
    } catch (error) {
        throw new Error("ContentUpdateAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Delete (Server Action)
 */
export const ContentDeleteAction = async <T extends Prisma.ContentDeleteArgs>(
    props: ContentDeleteProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentDeleteResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentDeleteAction", "Content", "delete");
        const response = await PrismaInstance.content.delete(props);
        return response;
    } catch (error) {
        throw new Error("ContentDeleteAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Create Many (Server Action)
 */
export const ContentCreateManyAction = async <T extends Prisma.ContentCreateManyArgs>(
    props: ContentCreateManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentCreateManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentCreateManyAction", "Content", "createMany");
        const response = await PrismaInstance.content.createMany(props);
        return response;
    } catch (error) {
        throw new Error("ContentCreateManyAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Update Many (Server Action)
 */
export const ContentUpdateManyAction = async <T extends Prisma.ContentUpdateManyArgs>(
    props: ContentUpdateManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentUpdateManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentUpdateManyAction", "Content", "updateMany");
        const response = await PrismaInstance.content.updateMany(props);
        return response;
    } catch (error) {
        throw new Error("ContentUpdateManyAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Delete Many (Server Action)
 */
export const ContentDeleteManyAction = async <T extends Prisma.ContentDeleteManyArgs>(
    props: ContentDeleteManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentDeleteManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentDeleteManyAction", "Content", "deleteMany");
        const response = await PrismaInstance.content.deleteMany(props);
        return response;
    } catch (error) {
        throw new Error("ContentDeleteManyAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Find First (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const ContentFindFirstAction = async <T extends Prisma.ContentFindFirstArgs>(
    props: ContentFindFirstProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentFindFirstResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentFindFirstAction", "Content", "findFirst");
        const response = await PrismaInstance.content.findFirst(props);
        return response;
    } catch (error) {
        throw new Error("ContentFindFirstAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Find Unique (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const ContentFindUniqueAction = async <T extends Prisma.ContentFindUniqueArgs>(
    props: ContentFindUniqueProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentFindUniqueResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentFindUniqueAction", "Content", "findUnique");
        const response = await PrismaInstance.content.findUnique(props);
        return response;
    } catch (error) {
        throw new Error("ContentFindUniqueAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Find Many (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const ContentFindManyAction = async <T extends Prisma.ContentFindManyArgs>(
    props: ContentFindManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentFindManyResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentFindManyAction", "Content", "findMany");
        const response = await PrismaInstance.content.findMany(props);
        return response;
    } catch (error) {
        throw new Error("ContentFindManyAction -> " + (error as Error).message);
    }
};

/**
 * ## Content Count (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const ContentCountAction = async <T extends Prisma.ContentCountArgs>(
    props: ContentCountProps<T>,
    disableSafeMessage: boolean = false,
): Promise<ContentCountResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "ContentCountAction", "Content", "count");
        const response = await PrismaInstance.content.count(props);
        return response;
    } catch (error) {
        throw new Error("ContentCountAction -> " + (error as Error).message);
    }
};
