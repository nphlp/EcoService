"use server";

import PrismaInstance from "@lib/prisma";
import { requiresSafeMessage } from "@permissions/requiresSafeMessage";
import { Prisma } from "@prisma/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";

/**
 * # Order Action Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/actions/{{model}}Action.hbs` as base template
 * - to generate server actions files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type OrderCreateProps<T extends Prisma.OrderCreateArgs> = Prisma.SelectSubset<T, Prisma.OrderCreateArgs>;
type OrderCreateResponse<T extends Prisma.OrderCreateArgs> = GetResult<
    Prisma.$OrderPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type OrderUpsertProps<T extends Prisma.OrderUpsertArgs> = Prisma.SelectSubset<T, Prisma.OrderUpsertArgs>;
type OrderUpsertResponse<T extends Prisma.OrderUpsertArgs> = GetResult<
    Prisma.$OrderPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type OrderUpdateProps<T extends Prisma.OrderUpdateArgs> = Prisma.SelectSubset<T, Prisma.OrderUpdateArgs>;
type OrderUpdateResponse<T extends Prisma.OrderUpdateArgs> = GetResult<
    Prisma.$OrderPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type OrderDeleteProps<T extends Prisma.OrderDeleteArgs> = Prisma.SelectSubset<T, Prisma.OrderDeleteArgs>;
type OrderDeleteResponse<T extends Prisma.OrderDeleteArgs> = GetResult<
    Prisma.$OrderPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type OrderCreateManyProps<T extends Prisma.OrderCreateManyArgs> = Prisma.SelectSubset<T, Prisma.OrderCreateManyArgs>;
type OrderCreateManyResponse = Prisma.BatchPayload;

// Update Many
type OrderUpdateManyProps<T extends Prisma.OrderUpdateManyArgs> = Prisma.SelectSubset<T, Prisma.OrderUpdateManyArgs>;
type OrderUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type OrderDeleteManyProps<T extends Prisma.OrderDeleteManyArgs> = Prisma.SelectSubset<T, Prisma.OrderDeleteManyArgs>;
type OrderDeleteManyResponse = Prisma.BatchPayload;

// Find First
type OrderFindFirstProps<T extends Prisma.OrderFindFirstArgs> = Prisma.SelectSubset<T, Prisma.OrderFindFirstArgs>;
type OrderFindFirstResponse<T extends Prisma.OrderFindFirstArgs> = GetResult<
    Prisma.$OrderPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type OrderFindUniqueProps<T extends Prisma.OrderFindUniqueArgs> = Prisma.SelectSubset<T, Prisma.OrderFindUniqueArgs>;
type OrderFindUniqueResponse<T extends Prisma.OrderFindUniqueArgs> = GetResult<
    Prisma.$OrderPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type OrderFindManyProps<T extends Prisma.OrderFindManyArgs> = Prisma.SelectSubset<T, Prisma.OrderFindManyArgs>;
type OrderFindManyResponse<T extends Prisma.OrderFindManyArgs> = GetResult<
    Prisma.$OrderPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type OrderCountProps<T extends Prisma.OrderCountArgs> = Prisma.SelectSubset<T, Prisma.OrderCountArgs>;
type OrderCountResponse<T extends Prisma.OrderCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.OrderCountAggregateOutputType>
        : number;

// ========== Services ========== //

/**
 * ## Order Create (Server Action)
 */
export const OrderCreateAction = async <T extends Prisma.OrderCreateArgs>(
    props: OrderCreateProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderCreateResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderCreateAction", "Order", "create");
        const response = await PrismaInstance.order.create(props);
        return response;
    } catch (error) {
        throw new Error("OrderCreateAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Upsert (Server Action)
 */
export const OrderUpsertAction = async <T extends Prisma.OrderUpsertArgs>(
    props: OrderUpsertProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderUpsertResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderUpsertAction", "Order", "upsert");
        const response = await PrismaInstance.order.upsert(props);
        return response;
    } catch (error) {
        throw new Error("OrderUpsertAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Update (Server Action)
 */
export const OrderUpdateAction = async <T extends Prisma.OrderUpdateArgs>(
    props: OrderUpdateProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderUpdateResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderUpdateAction", "Order", "update");
        const response = await PrismaInstance.order.update(props);
        return response;
    } catch (error) {
        throw new Error("OrderUpdateAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Delete (Server Action)
 */
export const OrderDeleteAction = async <T extends Prisma.OrderDeleteArgs>(
    props: OrderDeleteProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderDeleteResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderDeleteAction", "Order", "delete");
        const response = await PrismaInstance.order.delete(props);
        return response;
    } catch (error) {
        throw new Error("OrderDeleteAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Create Many (Server Action)
 */
export const OrderCreateManyAction = async <T extends Prisma.OrderCreateManyArgs>(
    props: OrderCreateManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderCreateManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderCreateManyAction", "Order", "createMany");
        const response = await PrismaInstance.order.createMany(props);
        return response;
    } catch (error) {
        throw new Error("OrderCreateManyAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Update Many (Server Action)
 */
export const OrderUpdateManyAction = async <T extends Prisma.OrderUpdateManyArgs>(
    props: OrderUpdateManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderUpdateManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderUpdateManyAction", "Order", "updateMany");
        const response = await PrismaInstance.order.updateMany(props);
        return response;
    } catch (error) {
        throw new Error("OrderUpdateManyAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Delete Many (Server Action)
 */
export const OrderDeleteManyAction = async <T extends Prisma.OrderDeleteManyArgs>(
    props: OrderDeleteManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderDeleteManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderDeleteManyAction", "Order", "deleteMany");
        const response = await PrismaInstance.order.deleteMany(props);
        return response;
    } catch (error) {
        throw new Error("OrderDeleteManyAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Find First (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const OrderFindFirstAction = async <T extends Prisma.OrderFindFirstArgs>(
    props: OrderFindFirstProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderFindFirstResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderFindFirstAction", "Order", "findFirst");
        const response = await PrismaInstance.order.findFirst(props);
        return response;
    } catch (error) {
        throw new Error("OrderFindFirstAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Find Unique (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const OrderFindUniqueAction = async <T extends Prisma.OrderFindUniqueArgs>(
    props: OrderFindUniqueProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderFindUniqueResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderFindUniqueAction", "Order", "findUnique");
        const response = await PrismaInstance.order.findUnique(props);
        return response;
    } catch (error) {
        throw new Error("OrderFindUniqueAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Find Many (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const OrderFindManyAction = async <T extends Prisma.OrderFindManyArgs>(
    props: OrderFindManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderFindManyResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderFindManyAction", "Order", "findMany");
        const response = await PrismaInstance.order.findMany(props);
        return response;
    } catch (error) {
        throw new Error("OrderFindManyAction -> " + (error as Error).message);
    }
};

/**
 * ## Order Count (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const OrderCountAction = async <T extends Prisma.OrderCountArgs>(
    props: OrderCountProps<T>,
    disableSafeMessage: boolean = false,
): Promise<OrderCountResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "OrderCountAction", "Order", "count");
        const response = await PrismaInstance.order.count(props);
        return response;
    } catch (error) {
        throw new Error("OrderCountAction -> " + (error as Error).message);
    }
};
