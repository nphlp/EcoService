"use server";

import PrismaInstance from "@lib/prisma";
import { requiresSafeMessage } from "@permissions/requiresSafeMessage";
import { Prisma } from "@prisma/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";

/**
 * # User Action Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/actions/{{model}}Action.hbs` as base template
 * - to generate server actions files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type UserCreateProps<T extends Prisma.UserCreateArgs> = Prisma.SelectSubset<T, Prisma.UserCreateArgs>;
type UserCreateResponse<T extends Prisma.UserCreateArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type UserUpsertProps<T extends Prisma.UserUpsertArgs> = Prisma.SelectSubset<T, Prisma.UserUpsertArgs>;
type UserUpsertResponse<T extends Prisma.UserUpsertArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type UserUpdateProps<T extends Prisma.UserUpdateArgs> = Prisma.SelectSubset<T, Prisma.UserUpdateArgs>;
type UserUpdateResponse<T extends Prisma.UserUpdateArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type UserDeleteProps<T extends Prisma.UserDeleteArgs> = Prisma.SelectSubset<T, Prisma.UserDeleteArgs>;
type UserDeleteResponse<T extends Prisma.UserDeleteArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type UserCreateManyProps<T extends Prisma.UserCreateManyArgs> = Prisma.SelectSubset<T, Prisma.UserCreateManyArgs>;
type UserCreateManyResponse = Prisma.BatchPayload;

// Update Many
type UserUpdateManyProps<T extends Prisma.UserUpdateManyArgs> = Prisma.SelectSubset<T, Prisma.UserUpdateManyArgs>;
type UserUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type UserDeleteManyProps<T extends Prisma.UserDeleteManyArgs> = Prisma.SelectSubset<T, Prisma.UserDeleteManyArgs>;
type UserDeleteManyResponse = Prisma.BatchPayload;

// Find First
type UserFindFirstProps<T extends Prisma.UserFindFirstArgs> = Prisma.SelectSubset<T, Prisma.UserFindFirstArgs>;
type UserFindFirstResponse<T extends Prisma.UserFindFirstArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type UserFindUniqueProps<T extends Prisma.UserFindUniqueArgs> = Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>;
type UserFindUniqueResponse<T extends Prisma.UserFindUniqueArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type UserFindManyProps<T extends Prisma.UserFindManyArgs> = Prisma.SelectSubset<T, Prisma.UserFindManyArgs>;
type UserFindManyResponse<T extends Prisma.UserFindManyArgs> = GetResult<
    Prisma.$UserPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type UserCountProps<T extends Prisma.UserCountArgs> = Prisma.SelectSubset<T, Prisma.UserCountArgs>;
type UserCountResponse<T extends Prisma.UserCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.UserCountAggregateOutputType>
        : number;

// ========== Services ========== //

/**
 * ## User Create (Server Action)
 */
export const UserCreateAction = async <T extends Prisma.UserCreateArgs>(
    props: UserCreateProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserCreateResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserCreateAction", "User", "create");
        const response = await PrismaInstance.user.create(props);
        return response;
    } catch (error) {
        throw new Error("UserCreateAction -> " + (error as Error).message);
    }
};

/**
 * ## User Upsert (Server Action)
 */
export const UserUpsertAction = async <T extends Prisma.UserUpsertArgs>(
    props: UserUpsertProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserUpsertResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserUpsertAction", "User", "upsert");
        const response = await PrismaInstance.user.upsert(props);
        return response;
    } catch (error) {
        throw new Error("UserUpsertAction -> " + (error as Error).message);
    }
};

/**
 * ## User Update (Server Action)
 */
export const UserUpdateAction = async <T extends Prisma.UserUpdateArgs>(
    props: UserUpdateProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserUpdateResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserUpdateAction", "User", "update");
        const response = await PrismaInstance.user.update(props);
        return response;
    } catch (error) {
        throw new Error("UserUpdateAction -> " + (error as Error).message);
    }
};

/**
 * ## User Delete (Server Action)
 */
export const UserDeleteAction = async <T extends Prisma.UserDeleteArgs>(
    props: UserDeleteProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserDeleteResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserDeleteAction", "User", "delete");
        const response = await PrismaInstance.user.delete(props);
        return response;
    } catch (error) {
        throw new Error("UserDeleteAction -> " + (error as Error).message);
    }
};

/**
 * ## User Create Many (Server Action)
 */
export const UserCreateManyAction = async <T extends Prisma.UserCreateManyArgs>(
    props: UserCreateManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserCreateManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserCreateManyAction", "User", "createMany");
        const response = await PrismaInstance.user.createMany(props);
        return response;
    } catch (error) {
        throw new Error("UserCreateManyAction -> " + (error as Error).message);
    }
};

/**
 * ## User Update Many (Server Action)
 */
export const UserUpdateManyAction = async <T extends Prisma.UserUpdateManyArgs>(
    props: UserUpdateManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserUpdateManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserUpdateManyAction", "User", "updateMany");
        const response = await PrismaInstance.user.updateMany(props);
        return response;
    } catch (error) {
        throw new Error("UserUpdateManyAction -> " + (error as Error).message);
    }
};

/**
 * ## User Delete Many (Server Action)
 */
export const UserDeleteManyAction = async <T extends Prisma.UserDeleteManyArgs>(
    props: UserDeleteManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserDeleteManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserDeleteManyAction", "User", "deleteMany");
        const response = await PrismaInstance.user.deleteMany(props);
        return response;
    } catch (error) {
        throw new Error("UserDeleteManyAction -> " + (error as Error).message);
    }
};

/**
 * ## User Find First (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const UserFindFirstAction = async <T extends Prisma.UserFindFirstArgs>(
    props: UserFindFirstProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserFindFirstResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserFindFirstAction", "User", "findFirst");
        const response = await PrismaInstance.user.findFirst(props);
        return response;
    } catch (error) {
        throw new Error("UserFindFirstAction -> " + (error as Error).message);
    }
};

/**
 * ## User Find Unique (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const UserFindUniqueAction = async <T extends Prisma.UserFindUniqueArgs>(
    props: UserFindUniqueProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserFindUniqueResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserFindUniqueAction", "User", "findUnique");
        const response = await PrismaInstance.user.findUnique(props);
        return response;
    } catch (error) {
        throw new Error("UserFindUniqueAction -> " + (error as Error).message);
    }
};

/**
 * ## User Find Many (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const UserFindManyAction = async <T extends Prisma.UserFindManyArgs>(
    props: UserFindManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserFindManyResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserFindManyAction", "User", "findMany");
        const response = await PrismaInstance.user.findMany(props);
        return response;
    } catch (error) {
        throw new Error("UserFindManyAction -> " + (error as Error).message);
    }
};

/**
 * ## User Count (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const UserCountAction = async <T extends Prisma.UserCountArgs>(
    props: UserCountProps<T>,
    disableSafeMessage: boolean = false,
): Promise<UserCountResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "UserCountAction", "User", "count");
        const response = await PrismaInstance.user.count(props);
        return response;
    } catch (error) {
        throw new Error("UserCountAction -> " + (error as Error).message);
    }
};
