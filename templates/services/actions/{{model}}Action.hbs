"use server";

import PrismaInstance from "@lib/prisma";
import { requiresSafeMessage } from "@permissions/requiresSafeMessage";
import { Prisma } from "@prisma/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";

/**
 * # {{modelName}} Action Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/actions/\{{model}}Action.hbs` as base template
 * - to generate server actions files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type {{modelName}}CreateProps<T extends Prisma.{{modelName}}CreateArgs> = Prisma.SelectSubset<T, Prisma.{{modelName}}CreateArgs>;
type {{modelName}}CreateResponse<T extends Prisma.{{modelName}}CreateArgs> = GetResult<
    Prisma.${{modelName}}Payload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type {{modelName}}UpsertProps<T extends Prisma.{{modelName}}UpsertArgs> = Prisma.SelectSubset<T, Prisma.{{modelName}}UpsertArgs>;
type {{modelName}}UpsertResponse<T extends Prisma.{{modelName}}UpsertArgs> = GetResult<
    Prisma.${{modelName}}Payload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type {{modelName}}UpdateProps<T extends Prisma.{{modelName}}UpdateArgs> = Prisma.SelectSubset<T, Prisma.{{modelName}}UpdateArgs>;
type {{modelName}}UpdateResponse<T extends Prisma.{{modelName}}UpdateArgs> = GetResult<
    Prisma.${{modelName}}Payload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type {{modelName}}DeleteProps<T extends Prisma.{{modelName}}DeleteArgs> = Prisma.SelectSubset<T, Prisma.{{modelName}}DeleteArgs>;
type {{modelName}}DeleteResponse<T extends Prisma.{{modelName}}DeleteArgs> = GetResult<
    Prisma.${{modelName}}Payload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type {{modelName}}CreateManyProps<T extends Prisma.{{modelName}}CreateManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.{{modelName}}CreateManyArgs
>;
type {{modelName}}CreateManyResponse = Prisma.BatchPayload;

// Update Many
type {{modelName}}UpdateManyProps<T extends Prisma.{{modelName}}UpdateManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.{{modelName}}UpdateManyArgs
>;
type {{modelName}}UpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type {{modelName}}DeleteManyProps<T extends Prisma.{{modelName}}DeleteManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.{{modelName}}DeleteManyArgs
>;
type {{modelName}}DeleteManyResponse = Prisma.BatchPayload;

// Find First
type {{modelName}}FindFirstProps<T extends Prisma.{{modelName}}FindFirstArgs> = Prisma.SelectSubset<T, Prisma.{{modelName}}FindFirstArgs>;
type {{modelName}}FindFirstResponse<T extends Prisma.{{modelName}}FindFirstArgs> = GetResult<
    Prisma.${{modelName}}Payload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type {{modelName}}FindUniqueProps<T extends Prisma.{{modelName}}FindUniqueArgs> = Prisma.SelectSubset<
    T,
    Prisma.{{modelName}}FindUniqueArgs
>;
type {{modelName}}FindUniqueResponse<T extends Prisma.{{modelName}}FindUniqueArgs> = GetResult<
    Prisma.${{modelName}}Payload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type {{modelName}}FindManyProps<T extends Prisma.{{modelName}}FindManyArgs> = Prisma.SelectSubset<T, Prisma.{{modelName}}FindManyArgs>;
type {{modelName}}FindManyResponse<T extends Prisma.{{modelName}}FindManyArgs> = GetResult<
    Prisma.${{modelName}}Payload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type {{modelName}}CountProps<T extends Prisma.{{modelName}}CountArgs> = Prisma.SelectSubset<T, Prisma.{{modelName}}CountArgs>;
type {{modelName}}CountResponse<T extends Prisma.{{modelName}}CountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.{{modelName}}CountAggregateOutputType>
        : number;

// ========== Services ========== //

/**
 * ## {{modelName}} Create (Server Action)
 */
export const {{modelName}}CreateAction = async <T extends Prisma.{{modelName}}CreateArgs>(
    props: {{modelName}}CreateProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}CreateResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}CreateAction", "{{modelName}}", "create");
        const response = await PrismaInstance.{{modelNameLower}}.create(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}CreateAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Upsert (Server Action)
 */
export const {{modelName}}UpsertAction = async <T extends Prisma.{{modelName}}UpsertArgs>(
    props: {{modelName}}UpsertProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}UpsertResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}UpsertAction", "{{modelName}}", "upsert");
        const response = await PrismaInstance.{{modelNameLower}}.upsert(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}UpsertAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Update (Server Action)
 */
export const {{modelName}}UpdateAction = async <T extends Prisma.{{modelName}}UpdateArgs>(
    props: {{modelName}}UpdateProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}UpdateResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}UpdateAction", "{{modelName}}", "update");
        const response = await PrismaInstance.{{modelNameLower}}.update(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}UpdateAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Delete (Server Action)
 */
export const {{modelName}}DeleteAction = async <T extends Prisma.{{modelName}}DeleteArgs>(
    props: {{modelName}}DeleteProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}DeleteResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}DeleteAction", "{{modelName}}", "delete");
        const response = await PrismaInstance.{{modelNameLower}}.delete(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}DeleteAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Create Many (Server Action)
 */
export const {{modelName}}CreateManyAction = async <T extends Prisma.{{modelName}}CreateManyArgs>(
    props: {{modelName}}CreateManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}CreateManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}CreateManyAction", "{{modelName}}", "createMany");
        const response = await PrismaInstance.{{modelNameLower}}.createMany(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}CreateManyAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Update Many (Server Action)
 */
export const {{modelName}}UpdateManyAction = async <T extends Prisma.{{modelName}}UpdateManyArgs>(
    props: {{modelName}}UpdateManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}UpdateManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}UpdateManyAction", "{{modelName}}", "updateMany");
        const response = await PrismaInstance.{{modelNameLower}}.updateMany(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}UpdateManyAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Delete Many (Server Action)
 */
export const {{modelName}}DeleteManyAction = async <T extends Prisma.{{modelName}}DeleteManyArgs>(
    props: {{modelName}}DeleteManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}DeleteManyResponse> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}DeleteManyAction", "{{modelName}}", "deleteMany");
        const response = await PrismaInstance.{{modelNameLower}}.deleteMany(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}DeleteManyAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Find First (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const {{modelName}}FindFirstAction = async <T extends Prisma.{{modelName}}FindFirstArgs>(
    props: {{modelName}}FindFirstProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}FindFirstResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}FindFirstAction", "{{modelName}}", "findFirst");
        const response = await PrismaInstance.{{modelNameLower}}.findFirst(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}FindFirstAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Find Unique (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const {{modelName}}FindUniqueAction = async <T extends Prisma.{{modelName}}FindUniqueArgs>(
    props: {{modelName}}FindUniqueProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}FindUniqueResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}FindUniqueAction", "{{modelName}}", "findUnique");
        const response = await PrismaInstance.{{modelNameLower}}.findUnique(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}FindUniqueAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Find Many (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const {{modelName}}FindManyAction = async <T extends Prisma.{{modelName}}FindManyArgs>(
    props: {{modelName}}FindManyProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}FindManyResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}FindManyAction", "{{modelName}}", "findMany");
        const response = await PrismaInstance.{{modelNameLower}}.findMany(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}FindManyAction -> " + (error as Error).message);
    }
};

/**
 * ## {{modelName}} Count (Server Action)
 * **WARNING**: Server actions can't be cached and parallelized
 * - Do not use this for fetching data, use API routes with caching instead
 * - But you can use it to get fresh data, without any cache
 */
export const {{modelName}}CountAction = async <T extends Prisma.{{modelName}}CountArgs>(
    props: {{modelName}}CountProps<T>,
    disableSafeMessage: boolean = false,
): Promise<{{modelName}}CountResponse<T>> => {
    try {
        await requiresSafeMessage(disableSafeMessage, "{{modelName}}CountAction", "{{modelName}}", "count");
        const response = await PrismaInstance.{{modelNameLower}}.count(props);
        return response;
    } catch (error) {
        throw new Error("{{modelName}}CountAction -> " + (error as Error).message);
    }
};
