"use server";

import {{modelName}}Service from "@services/class/{{modelName}}Class";
import { {{modelName}}CountProps, {{modelName}}CountResponse, {{modelName}}CreateManyProps, {{modelName}}CreateManyResponse, {{modelName}}CreateProps, {{modelName}}CreateResponse, {{modelName}}DeleteManyProps, {{modelName}}DeleteManyResponse, {{modelName}}DeleteProps, {{modelName}}DeleteResponse, {{modelName}}FindFirstProps, {{modelName}}FindFirstResponse, {{modelName}}FindManyProps, {{modelName}}FindManyResponse, {{modelName}}FindUniqueProps, {{modelName}}FindUniqueResponse, {{modelName}}UpdateManyProps, {{modelName}}UpdateManyResponse, {{modelName}}UpdateProps, {{modelName}}UpdateResponse, {{modelName}}UpsertProps, {{modelName}}UpsertResponse } from "@services/types/{{modelName}}Type";

// ========== Single mutations ========== //

export const {{modelName}}CreateAction = async <T extends {{modelName}}CreateProps>(props: T): Promise<{{modelName}}CreateResponse<T>> => {
    try {
        const { data, error } = await {{modelName}}Service.create(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}Create -> " + (error as Error).message);
    }
};

export const {{modelName}}UpsertAction = async <T extends {{modelName}}UpsertProps>(props: T): Promise<{{modelName}}UpsertResponse<T>> => {
    try {
        const { data, error } = await {{modelName}}Service.upsert(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}Upsert -> " + (error as Error).message);
    }
};

export const {{modelName}}UpdateAction = async <T extends {{modelName}}UpdateProps>(props: T): Promise<{{modelName}}UpdateResponse<T>> => {
    try {
        const { data, error } = await {{modelName}}Service.update(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}Update -> " + (error as Error).message);
    }
};

export const {{modelName}}DeleteAction = async <T extends {{modelName}}DeleteProps>(props: T): Promise<{{modelName}}DeleteResponse<T>> => {
    try {
        const { data, error } = await {{modelName}}Service.delete(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}Delete -> " + (error as Error).message);
    }
};

// ========== Multiple mutations ========== //

export const {{modelName}}CreateManyAction = async (props: {{modelName}}CreateManyProps): Promise<{{modelName}}CreateManyResponse> => {
    try {
        const { data, error } = await {{modelName}}Service.createMany(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}CreateMany -> " + (error as Error).message);
    }
};

export const {{modelName}}UpdateManyAction = async (props: {{modelName}}UpdateManyProps): Promise<{{modelName}}UpdateManyResponse> => {
    try {
        const { data, error } = await {{modelName}}Service.updateMany(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}UpdateMany -> " + (error as Error).message);
    }
};

export const {{modelName}}DeleteManyAction = async (props: {{modelName}}DeleteManyProps): Promise<{{modelName}}DeleteManyResponse> => {
    try {
        const { data, error } = await {{modelName}}Service.deleteMany(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}DeleteMany -> " + (error as Error).message);
    }
};

// ========== Single queries ========== //

/**
 * WARNING: do not use this for fetching data -> use API routes with caching instead
 */
export const {{modelName}}FindFirstAction = async <T extends {{modelName}}FindFirstProps>(
    props: T
): Promise<{{modelName}}FindFirstResponse<T>> => {
    try {
        const { data, error } = await {{modelName}}Service.findFirst(props);
        if (error) throw new Error(error);
        return data ?? null;
    } catch (error) {
        throw new Error("{{modelName}}FindFirst -> " + (error as Error).message);
    }
};

/**
 * WARNING: do not use this for fetching data -> use API routes with caching instead
 */
export const {{modelName}}FindUniqueAction = async <T extends {{modelName}}FindUniqueProps>(
    props: T
): Promise<{{modelName}}FindUniqueResponse<T>> => {
    try {
        const { data, error } = await {{modelName}}Service.findUnique(props);
        if (error) throw new Error(error);
        return data ?? null;
    } catch (error) {
        throw new Error("{{modelName}}FindUnique -> " + (error as Error).message);
    }
};

/**
 * WARNING: do not use this for fetching data -> use API routes with caching instead
 */
export const {{modelName}}FindManyAction = async <T extends {{modelName}}FindManyProps>(
    props: T
): Promise<{{modelName}}FindManyResponse<T>> => {
    try {
        const { data, error } = await {{modelName}}Service.findMany(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}FindMany -> " + (error as Error).message);
    }
};

// ========== Aggregate queries ========== //

/**
 * WARNING: do not use this for fetching data -> use API routes with caching instead
 */
export const {{modelName}}CountAction = async (props: {{modelName}}CountProps): Promise<{{modelName}}CountResponse> => {
    try {
        const { data, error } = await {{modelName}}Service.count(props);
        if (!data || error) throw new Error(error);
        return data;
    } catch (error) {
        throw new Error("{{modelName}}Count -> " + (error as Error).message);
    }
};
