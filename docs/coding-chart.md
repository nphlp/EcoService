# Coding Chart

[Home](../README.md) > [Coding Chart](./coding-chart.md)

Here are some best practices to follow for consistent, robust and maintainable code.

<h2>Summary</h2>

- [Member naming](#member-naming)
    - [UPPER_CASE](#upper_case)
    - [kebab-case](#kebab-case)
    - [PascalCase](#pascalcase)
    - [camelCase](#camelcase)
- [Function declarations](#function-declarations)
    - [1. Server Components](#1-server-components)
    - [2. Client Components](#2-client-components)
    - [3. Fetch and mutations](#3-fetch-and-mutations)
    - [4. Server Actions or Process (mutations)](#4-server-actions-or-process-mutations)
    - [5. API routes (fetch or external APIs)](#5-api-routes-fetch-or-external-apis)

## Member naming

### UPPER_CASE

For fixed values shared across the codebase.

```ts
// Fixed values
const MY_FIXED_NUMBER = 150;

// Env variables
const BASE_URL = process.env.BASE_URL;
```

### kebab-case

For files and folders names.

```bash
# Folder name
./my-folder/and-sub-folder/

# File name
my-file.txt
```

### PascalCase

For classes, components and server actions.

```ts
// Class
class MyClass {
    // ...
}

// Component
const MyComp = () => {
    // ...
};

export const MyServerAction = async () => {
    // ...
};
```

### camelCase

For constants and functions.

> [!WARNING]
>
> `let` and `var` are prohibited

```ts
const myVariable = "value";
const myFunction = () => {
    // ...
};
```

## Function declarations

Here are the main types of files and function declaration patterns in Next.js.

### 1. Server Components

- Server-side rendering
- Located in the `/app/` folder
- It is strongly recommended that all `page.tsx` files be `Server Components`
- Can fetch data from the database directly in the function body
- Can render `server components` or `client components`
- Cannot contain **React hooks**!!

```tsx
// Type your props here
type PageProps = {
    params: Promise<{ slug: string }>; // optional
};

// Use ES6 function
const Page = (props: PageProps) => {
    // Destructure props
    const { params } = props;
    const { slug } = await params;

    // Get data from the database
    const myServerData = await fetchData(slug);

    // Return JSX
    return <div>{myServerData}</div>;
};

export default Component;
```

### 2. Client Components

- Client-side rendering
- Located in the `/app/my-page/` folder (component used in only one place) and `/components/` folder (reusable component)
- Can contain **React hooks**
- Can only render `client components`
- Cannot fetch data from the database directly in the function body. Here are some solutions:
    - Fetch data from the parent server component to hydrate `useState`
    - Use a dedicated fetch hook, like `useFetch` in this project
    - Use a `server action` to perform a mutation
    - Avoid using `useEffect` to fetch data

```tsx
"use client";

// Type your props here
type ComponentProps = {
    myString: string;
};

// Use ES6 function
const Component = (props: ComponentProps) => {
    // Destructure props
    const { myString } = props;

    // Use state
    const [myState, setMyState] = useState(myString);

    // Use effect
    useEffect(() => {
        // ...
    }, [myState]);

    // Return JSX
    return (
        <div>
            <div>{myState}</div>
            <button onClick={() => setMyState("new value")}>Click me</button>
        </div>
    );
};

export default Component;
```

### 3. Fetch and mutations

> [!NOTE]
> What I call `CRUD Prisma` is the system that generates the `fetch` and `mutations` functions from the following Prisma methods.
>
> CREATE: `create` and `createMany` \
> READ: `findFirst`, `findUnique` and `findMany` \
> UPDATE: `update` and `updateMany` \
> DELETE: `delete` and `deleteMany`
>
> Other methods: `upsert`, `upsertMany`, `count`, etc...

The `CRUD Prisma` type fetch and mutation functions are automatically generated by the `pnpm generate:all` command from the `/prisma/schema.prisma`. More information about the [CRUD Prisma generation system here](./crud-prisma.md).

If you need to create custom fetch and mutation functions, you can do so by following these patterns.

### 4. Server Actions or Process (mutations)

- Executes only on the server -> called from `client components` or `server components`
- Executes in series, cannot be parallelized -> dedicated to mutations or fetch without cache
- Do not use for data fetching (no cache)
- Use primarily to perform mutations on the database
- Very useful for performing a series of validations before a mutation
- Actions are stored in the `/process/` folder

```ts
"use server";

// Type your props here
type MyServerActionProps = {
    userId: string;
    myString: string;
};

// Validate props with Zod
const myServerActionSchema: ZodType<MyServerActionProps> = z.object({
    userId: z.string(),
    myString: z.string(),
});

// Type your response here
type MyServerActionResponse = {
    myUpdatedString: string;
};

// Use ES6 function
export const MyServerAction = async (props: MyServerActionProps): Promise<MyServerActionResponse> => {
    try {
        // Destructure and validate props
        const { myString } = myServerActionSchema.parse(props);

        // Mutate data into the database
        const myUpdatedString = await PrismaInstance.user.update({
            where: { id: userId },
            data: { name: myString },
        });

        // Return response
        return { myUpdatedString };
    } catch (error) {
        console.error(error);
        return "Something went wrong...";
    }
};
```

### 5. API routes (fetch or external APIs)

- Dedicated to fetch operations (caching possibility)
- Useful for communications with external APIs (e.g., Stripe)
- Prefer auto-generated `routes` by the `pnpm generate:all` command
- Avoid using for mutations, prefer `server actions` which are designed for that
- Located in the `/app/api/` folder

Here is the standard response format for `API routes`.

```ts
// Response format
export type ResponseFormat<Response> = { data: Response; error?: undefined } | { data?: undefined; error: string };
```

Here is an example of fetch with cache.

```ts
// Type your props here
export type ApiRouteNameProps = {
    myString: string;
};

// Validate props with Zod
const apiRouteNamePropsSchema: ZodType<ApiRouteNameProps> = z.object({
    myString: z.string(),
});

// Type your response here
export type ApiRouteNameResponse = {
    myData: string;
};

export async function GET(request: NextRequest): Promise<NextResponse<ResponseFormat<ApiRouteNameResponse>>> {
    try {
        // Decode and parse URL params
        const params: CreateStripePriceProps = parseAndDecodeParams(request);

        // Destructure and validate params
        const { myString } = apiRouteNamePropsSchema.parse(params);

        // Fetch data from the database
        const myData = await PrismaInstance.product.findUnique({
            where: { id: myString },
        });

        // Return response
        return NextResponse.json({ data: myData }, { status: 200 });
    } catch (e) {
        const error = StripeError("/prices/create", e);
        return NextResponse.json({ error }, { status: 500 });
    }
}
```
